# Lisp. Транслятор и модель

- Лебедев Вячеслав Владимирович, P33312
- lisp | acc | harv | hw | tick | struct | stream | port | pstr | prob1 | 8bit
- усложнение `8bit` не реализовано

TODO:

- объяснить подробнее каждое ключевое слово
- уменьшить число тактов для исполнения инструкций?

## Язык программирования

### Синтаксис

```ebnf
<program>               := <expressions> EOF

<expressions>           := | <expressions> <expression>

<expression>            := <open-bracket> <bracketed-expression> <close-bracket> | <varname> | <literal>

<bracketed-expression>  :=  <function-definition> 
                            | <function-call> 
                            | <if-condition> 
                            | <binary-operation> 
                            | <unary-operator-expression>
                            | <assignment> 
                            | <loop-expression>
                            | <allocation>

<function-call>         := <varname> <arguments>

<arguments>             := | <arguments> <expression>

<function-definition>   := defun <varname> <open-bracket> <parameters> <close-bracket> <expressions>

<parameters>            := | <parameters> <varname>

<assignment>            := setq <varname> <expr>

<allocation>            := alloc <number-literal>

<if-condition>          := if <condition-expression> <true-expression> <false-expression>

<loop-expression>       := loop <condition-expression> <expressions> 

<binary-operator-expression> := <binary-operator> <expression> <expression>

<unary-operator-expression> := <unary-operator> <expression>

<binary-operator>       := store | mod | and | or | + | - | = | < | >

<unary-operator>        := not | put | load

<nullary-operator>      := get

<condition-expression>  := <expression>

<true-expression>       := <expression>

<false-expression>      := <expression>

<literal>               := <number-literal> | <string-literal> | <character-literal>

<number-literal>        := [0-9]+

<string-literal>        := "\w*"

<character-literal>     := '.'

<varname>               := [a-zA-Z]\w*
```

### Семантика

Каждая операция является `выражением`, т.е. в результате вычисления "возвращает" результат.
Выполнение программы представляет собой последовательное вычисление таких выражений.
Например, выражение `(+ 1 (+ 2 3))` вычисляется так: `(+ 1 (+ 2 3)) -> (+ 1 5) -> 6`.

`setq` - объявляет переменную (если не была объявлена) и присваивает ей значение.
В зависимости от того, где объявлена переменная, она также имеет свою область видимости.
Глобальную область получают переменные объявленные вне определения функции, а локальную -
внутри определения функции, а также параметры функции.

Все переменные существуют только в рамках своей видимости: из глобальной невозможно обратиться к
локальным переменным функции, а из функции невозможно обратиться к глобальным переменным.

Код в глобальной области представляет собой список выражений, которые будут вычислены последовательно.
Тело функций тоже представляет собой список выражений, которые вычисляются последовательно.
При этом результат вычисления последнего выражения является результатом функции.

Ключевые слова:

- `get` - прочитать значение извне
- `put` - вывести значение
- `alloc` - выделить буфер в статической памяти
- `load` - прочитать значение из ячейки по адресу
- `store` - загрузить значение в ячейку по адресу
- `setq` - присвоить значение переменной (и/или объявить переменную)
- `defun` - объявить функцию

### Типы данных

Существует единственный тип - 32-битное знаковое число, интерпретация которого ложится на плечи программиста.
Так, например, `(alloc <number>)` - выделить буфер определенного размера в статической памяти, возвращает число -
адрес буфера - от 0 до 2^24-1 (результат вычисления строкового литерала аналогичен). Поэтому если сделать
вызов `(load -1)`, то произойдет исключение, потому что
адрес вышел за границы.

## Организация памяти

1. Память команд. Машинное слово - 32 бит. Реализуется списком словарей, описывающих инструкции (одно слово - одна
   команда). Размер адресного пространства - 2^24 слов.
2. Память данных. Машинное слово - 32 бит, знаковое. Линейное адресное пространство. Реализуется списком чисел. Размер
   адресного пространства - 2^24 слов.

### Регистры

- `AC` (Accumulator) - аккумулятор
- `CR` (Command Register) - используется для хранения текущей исполняемой инструкции
- `IP` (Instruction Pointer) - указатель инструкций
- `DR` (Data Register) - регистр данных (для работы с памятью и вводом/выводом)
- `AR` (Address Register) - адресный регистр (используется при чтении/записи в память)
- `SP` (Stack Pointer) - указатель стека
- `FP` (Frame Pointer) - указатель фрейма
- `BR` (Buffer Pointer) - используется во время выполнения промежуточных операций при исполнении инструкции

Так как это модель аккумуляторного процессора, то пользователь может явно работать только с аккумулятором.
Но помимо этого есть команды для неявного взаимодействия с другими регистрами (`pop` - декремент указателя стека,
`jmp` - установить значение в указатель инструкций).

### Виды Адресации

- `Absolute` - абсолютная, указывается адрес, где находится значение: `value = MEM[address]`
- `Relative` - относительная, указывается регистр и смещение `value = MEM[register + offset]`
- `Relative Inderect` - косвенная относительная, указывается регистр и смещение: `value = MEM[MEM[register + offset]]`

В качестве регистра можно указывать `Stack Pointer` и `Frame Pointer`.
Относительная адресация используется для работы со стеком и локальными переменными функций.

Число команд - 20, поэтому код инструкции имеет размер 5 бит (20 < 32 = 2 ^ 5).
Также, так как типов операндов - 4, то на их кодирование требуется еще 2 бита.
И 1 бит необходим для кодирования регистра при относительной адресации.
Остается 24 бита. Из-за этого адресное пространство ограничивается 24 битами,
поэтому память данных также ограничена: ее максимальный объем - 16777216 слов размером 32 бита.

Команды перехода отнесены в отдельную категорию, так как в их случае операнд - не адрес данных, а адрес инструкций.
Поэтому их цикл выборки операнда отличается от адресных команд, операнд в данном случае хранится внутри самой инструкции
в сегменте кода.

Схема адресных команд:

| Вид Операнда                | Схема                                                  |
|-----------------------------|--------------------------------------------------------|
| `Relative Address`          | `[OPCODE: 5][ADDRESSING: 2][REGISTER: 1][OFFSET: 24]`  |
| `Relative Inderect Address` | `[OPCODE: 5][ADDRESSING: 2][REGISTER: 1][OFFSET: 24]`  |
| `Absolute Address`          | `[OPCODE: 5][ADDRESSING: 2][RESERVED: 1][ADDRESS: 24]` |
| `Execution Flow Address`    | `[OPCODE: 5][RESERVED: 3][ADDRESS: 24]`                |

### Литералы

Каждый литерал является Lisp-выражением, таким образом в результате своего "вычисления" должен стать значением на стеке.

- строковые - сама строка помещается в статическую память, закодированную в pascal-style, после "вычисления" помещает
  адрес строки на стек
- числовые - при компиляции значение помещается в 1 ячейку статической памяти, при "вычислении" на стек помещается
  число, вычитанное из статической памяти
- символьные - по организации в памяти аналогичны числовым литералам, по сути - являются макросом, чтобы не писать
  каждый раз ASCII код

### Размещение данных

```text
       Instruction memory
+------------------------------+
| 00  : nop  (program start)   |
|    ...                       |
| xx  : halt  (program stop)   |
|    ...                       |
| i   : nop  (function "foo")  |
| i+1 : function body          |
|    ...                       |
| j   : nop  (function "baz")  |
| j+1 : function body          |
|    ...                       |
+------------------------------+

          Data memory
+------------------------------+
| 00  : 42  (number literal)   |
|    ...                       |
| i   : 111 (char literal 'o') |
|    ...                       |
| j   : 5 (string literal)     |
| j+1 : 104 ('h')              |
| j+2 : 101 ('e')              |
| j+3 : 108 ('l')              |
| j+4 : 108 ('l')              |
| j+5 : 111 ('o')              |
|    ...                       |
| k   : 0 (static variable x)  |           ^
|    ...                       |           | 
| ff : ...                     | <- stack top
+------------------------------+
```

## Система Команд Процессора

### Набор инструкций

| №  | инструкция | эффект                              | описание                                                |
|----|------------|-------------------------------------|---------------------------------------------------------|
| 1  | `add A`    | `AC + MEM[A] -> AC`                 | сложение знаковых числ                                  |
| 2  | `sub A`    | `AC - MEM[A] -> AC`                 | вычитание знаковых числ                                 |
| 3  | `and A`    | `AC & MEM[A] -> AC`                 | побитовое логическое "И"                                |
| 4  | `or A`     | `AC v MEM[A] -> AC`                 | побитовое логическое "ИЛИ"                              |
| 5  | `not`      | `~AC         -> AC`                 | побитовое логическое "НЕ"                               |
| 6  | `ld A`     | `MEM[A] -> AC`                      | загрузка значения в аккумулятор по адресу               |
| 7  | `st A`     | `AC -> MEM[A]`                      | сохранение значения из аккумулятора по адресу           |
| 8  | `put`      | `AC -> IO`                          | вывод значения из аккумулятора                          |
| 9  | `get`      | `IO -> AC`                          | ввод значения в аккумулятор                             |
| 10 | `push`     | `SP - 1 -> SP`                      | подъем указателя стека                                  |
| 11 | `pop`      | `SP + 1 -> SP`                      | понижение указателя стека                               |
| 12 | `jmp A`    | `A -> IP`                           | безусловный переход                                     |
| 13 | `jz A`     | `A -> IP, if AC == 0`               | переход, если в аккумуляторе `0`                        |
| 14 | `call A`   | `IP -> STACK, FP -> STACK, A -> IP` | вызов функции                                           |
| 15 | `ret`      | `STACK -> FP, STACK -> IP`          | возврат из функции                                      |
| 16 | `ispos`    | `(AC > 0) -> AC`                    | проверка, что в аккумуляторе строго положительное число |
| 17 | `isneg`    | `(AC < 0) -> AC`                    | проверка, что в аккумуляторе строго отрицательное число |
| 18 | `iszero`   | `(AC == 0) -> AC`                   | проверка, что в аккумуляторе `0`                        |
| 19 | `nop`      |                                     | бездействие                                             |
| 20 | `halt`     |                                     | остановка исполнения                                    |

### Исполнение инструкций

```text
Instruction Fetch:
IMEM[IP] -> CR
IP + 1 -> IP


Operand Fetch (for commands with operand):
ABSOLUTE ADDRESS:
    CR[8:31]    -> AR
    MEM[AR]     -> DR

RELATIVE ADDRESS:
    CR[8:31]    -> BR
    BR + $reg   -> AR
    MEM[AR]     -> DR
    
RELATIVE INDIRECT ADDRESS:
    CR[8:31]    -> BR
    BR + $reg   -> AR
    MEM[AR]     -> DR
    DR          -> AR
    MEM[AR]     -> DR

EXECUTION FLOW ADDRESS:
    CR[8:31]    -> DR


Execution:
add, sub, mod, and, or:
    AC + DR -> AC

not:
    NOT(AC) -> AC
    
jmp:
    DR -> IP

jz:
    DR -> IP, if FLAGS[ZERO] == 1

call:
    DR      -> BR
    IP      -> DR       % save IP
    SP      -> AR
    DR      -> MEM[AR]
    SP - 1  -> SP
    FP      -> DR       % save FP
    SP      -> AR
    DR      -> MEM[AR]
    SP - 1  -> SP
    SP      -> FP
    BR      -> IP       % jump

ret:
    SP + 1  -> SP       % recover FP
    SP      -> AR
    MEM[AR] -> DR
    DR      -> FP
    SP + 1  -> SP       % recover IP
    SP      -> AR
    MEM[AR] -> DR
    DR      -> IP
    
ld:
    DR      -> AR
    MEM[AR] -> DR
    DR      -> AC
    
st:
    DR      -> AR
    AC      -> DR
    DR      -> MEM[AR]
 
push:
    SP - 1  -> SP
 
pop:
    SP + 1  -> SP

put:
    AC      -> DR
    DR      -> IO

get:
    IO      -> DR
    DR      -> AC

ispos:
    (AC > 0) -> AC

isneg:
    (AC < 0) -> AC

iszero:
    (AC == 0) -> AC
```

### Соглашение о вызове функций

**Вызов**

Для исполнения Lisp функции, объявленной при помощи `defun`

`Caller`:

- на стек помещаются аргументы функции после вычисления `k` выражений (число аргументов всегда **равно** числу
  параметров, принимаемых функцией)
- происходит вызов инструкции `call A`:
    - на стек помещается адрес возврата (текущий `IP`)
    - сохраняется текущий указатель стека `FP`
    - устанавливается новый указатель фрейма функции: `SP -> FP`
    - происходит переход на инструкции функции: `A -> IP`

`Callee`:

- на стеке выделяется неинициализированная память для локальных переменных функции
  (во время компиляции **известно** число локальных переменных функции).

**Выполнение функции и результат**

Выражения тела функции вычисляются последовательно. Последнее выражение - результат функции, помещается на стек.

**Возврат**

Результат функции - всегда **одно** слово, помещенное на стек

`Callee`:

- результат снимается со стека и сохраняется в аккумулятор
- снимаются локальные переменные - производится `n` вызовов `pop`
- происходит вызов `ret` - восстанавливается предыдущий `Frame Pointer` и `Instruction Pointer`

`Caller`:

- снимаются аргументы функции - производится `k` вызовов `pop`
- результат из аккумулятора помещается на стек

Доступ к локальным переменным осуществляется при помощи относительной адресации в сторону младших адресов
`address_of(local_var[i]) = fp - i, где i = [0..n-1]`.

Доступ к аргументам тоже осуществляется относительно указателя фрейма,
но в сторону старших адресов: `address_of(arg[i]) = fp - i + k + 2, где i = [0..k-1]`
(смещение +2 появляется из-за того, что `FP` расположен на 2 адреса выше последнего параметра).

```text
0x0000  | ...            | 
        :                :
        |                | <- SP
        | result         | 
        | local var n-1  |
        | ...            |
        | local var 0    | <- FP    % frame i + 1
        +----------------+
        | old frame ptr  |
        | return address |
        | arg k-1        |
        | ...            |
        | arg 0          |
        | ...            |          % frame i
        :                :
0xffff  | ...            |
```

### Кодирование инструкций и данных

- Машинный код сериализуется в список JSON.
- Один элемент списка - одно машинное слово, одна инструкция
- Индекс списка - адрес инструкции, используется при командах перехода

Пример:

```json
[
  {
    "index": 11,
    "opcode": "ld",
    "operand": {
      "type": "absolute",
      "address": 0
    },
    "debug": "variable value [char]"
  },
  {
    "index": 12,
    "opcode": "push"
  },
  {
    "index": 15,
    "opcode": "sub",
    "operand": {
      "type": "relative",
      "register": "sp",
      "offset": 1
    }
  }
]
```

где:

- `opcode` - строка с кодом операции
- `operand` - операнд, для команд перехода - адрес инструкции, для адресных команд - адрес (абсолютный, относительный,
  косвенный)
- `debug`, `index` - дополнительная информация для дебага, не используется при исполнении инструкции

Типы данных описаны в [isa](translator/isa.py), где:

- `Opcode` - перечисление кодов операций;
- `Addressing` - перечисление типов адресации
- `Register` - перечисление регистров, используемых для относительной адресации

Статическая область памяти сериализуется в виде JSON массива чисел

Пример:
(`"hello"` закодированное в виде Pascal строки)

```json
[
  5,
  104,
  101,
  108,
  108,
  111
]
```

## Транслятор

Состоит из 4 основных файлов:

- [lexer.py](translator/lexer.py)
- [parsing.py](translator/parsing.py)
- [compiler.py](translator/compiler.py)
- [translator.py](translator/translator.py)

### Лексер

Содержит enums для токенов, а также соответствующие им паттерны, описанные в виде элементарных регулярных выражений.
А также два класса - `Lexer` и `Token`. `Lexer` содержит основную логику по разбиению исходного кода на токены.
А `Token` в себе инкапсулирует информацию о токене (тип, дополнительная информация).

### Парсер

На основе токенов, полученных от лексера формирует абстрактное синтаксическое дерево.
Внутри файла объявлены классы - узлы дерева. А также класс `Parser`, содержащий в себе основную логику.

Парсер объединяет токены в узлы дерева по правилам, описанным выше в форме Бэкуса-Нуара.

### Компилятор

Получает на вход абстрактное синтаксическое дерево от парсера, на основе которого формирует
линейный код в виде списка инструкций, описанных в [isa.py](machine/isa.py).

Внутри файла находится 3 основных класса:

- `DataSegment` - управляет размещением статических данных
- `TextSegment` - управляет размещением инструкций в сегменте кода
- `Compiler` - содержит основную логику по преобразованию `AST` в код

Основное правило компиляции - каждое Lisp-выражение должно быть преобразовано в
значение на стеке. Таким образом, каждое выражение помещает результат на стек, а
вызвавшее его выражение - снимает его и использует в вычислении.

Иногда это может привести к избыточной работе со стеком, но зато упрощает процесс
написания компилятора и избавляет от необходимости думать о состоянии аккумулятора
и размещении переменных

### Транслятор

- соединяет исходный код со стандартной библиотекой
- использует перечисленные файлы для преобразования исходного кода
- обеспечивает работу с командной строкой
